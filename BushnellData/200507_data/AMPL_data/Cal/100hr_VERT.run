options presolve 0; 
option path_options "cumulative_iteration_limit = 40000";
option path_options "output = no";
# display b;

option reset_initial_guesses 0;

param COUNTER;

for {INIT in COURNOT}
{
let contractpct[INIT] := 0;
};


let ST := 1;
let T := 100;
repeat while T <= 700
{
let COUNTER := 1;
for {VERT in COURNOT}
{
for {INIT in COURNOT}
{
let perturb[INIT] := 0;
};
let perturb[VERT] := perturb[VERT] + .01;
for {ITER in 1..1} 
{
let BOOT_RUN := ITER;
solve;
solve;
solve;
if solve_result = "solved" then
{
option display_width 350;
option display_1col 3500;
option display_round 3;
display  {t in ST..T} 
((BT+t)/1000,BOOT_RUN,a[t], b[BOOT_RUN],COUNTER,qc[VERT,t], 
p[t], 
q["AES",t], q["DUKE",t], q["DYN",t], q["MIR",t], q["REL",t], q["FR",t],
TC["AES",t], TC["DUKE",t], TC["DYN",t], TC["MIR",t], TC["REL",t], TC["FR",t]);
};
};
let COUNTER := COUNTER + 1;
};
let T := T + 100;
let ST := ST + 100;
};

let ST := 701;
let T := Tdata;
let COUNTER := 1;
for {VERT in COURNOT}
{
for {INIT in COURNOT}
{
let perturb[INIT] := 0;
};
let perturb[VERT] := perturb[VERT] + .01;
for {ITER in 1..1} 
{
let BOOT_RUN := ITER;
solve;
solve;
solve;
if solve_result = "solved" then
{
option display_width 350;
option display_1col 3500;
option display_round 3;
display  {t in ST..T} 
((BT+t)/1000,BOOT_RUN,a[t], b[BOOT_RUN],COUNTER,qc[VERT,t],
p[t], 
q["AES",t], q["DUKE",t], q["DYN",t], q["MIR",t], q["REL",t], q["FR",t],
TC["AES",t], TC["DUKE",t], TC["DYN",t], TC["MIR",t], TC["REL",t], TC["FR",t]);
};
};
let COUNTER := COUNTER + 1;
};

